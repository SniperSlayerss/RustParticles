use crate::components::particle::Particle;
use crate::simulation_parameters::SimulationParameters;
use crate::systems::collision_system::resolve_collisions;
use bevy::prelude::*;

pub fn update_system(
    time: Res<Time>,
    parameters: Res<SimulationParameters>,
    mut query: Query<(&mut Transform, &mut Particle), With<Particle>>,
) {
    let delta_time = time.delta_seconds();
    let gravity = parameters.gravity;

    for (_, mut particle) in query.iter_mut() {
        apply_gravity(&mut particle, gravity, delta_time);
    }

    for (mut transform, mut particle) in query.iter_mut() {
        check_and_place_within_bounds(&mut transform, &mut particle, parameters.boundary_radius);
    }

    let mut particles: Vec<(Vec3, Vec3, f32)> = query
        .iter()
        .map(|(transform, particle)| (transform.translation, particle.velocity, particle.radius))
        .collect();
    for _ in 0..1 {
        resolve_collisions(&mut particles, 0.7);
    }
    // Update the query with new positions
    for ((mut transform, mut particle), (new_pos, new_vel, _)) in
        query.iter_mut().zip(particles.into_iter())
    {
        transform.translation = new_pos;
        particle.velocity = new_vel;
    }

    // Update position and check boundaries
    for (mut transform, mut particle) in query.iter_mut() {
        update_position(&mut transform, &mut particle, delta_time);
    }
}

fn update_position(transform: &mut Transform, particle: &mut Particle, delta_time: f32) {
    transform.translation += particle.velocity * delta_time;
}

fn apply_gravity(particle: &mut Particle, gravity: Vec3, delta_time: f32) {
    particle.velocity += gravity * delta_time * 0.7;
}

fn check_and_place_within_bounds(
    transform: &mut Transform,
    particle: &mut Particle,
    boundary_radius: f32,
) {
    let current_distance = transform.translation.length();
    let max_distance = boundary_radius - particle.radius;

    if current_distance > max_distance {
        let direction_to_origin = -transform.translation;
        let normalized_direction = direction_to_origin.normalize();

        // Apply a small buffer to ensure the particle is slightly inside the boundary
        let buffer_distance = 0.01;
        transform.translation = -normalized_direction * (max_distance - buffer_distance);

        let restitution = 0.7;
        let velocity_normal_component = particle.velocity.dot(normalized_direction);
        particle.velocity -= normalized_direction * (1.0 + restitution) * velocity_normal_component;
    }
}
